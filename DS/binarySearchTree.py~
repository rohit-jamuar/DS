#!/usr/bin/python

from treeNode import Node
from queue import queue

class BST:
	'''Binary Search Tree'''	
	def __init__(self):
		   self.__root=None

	@property
	def root(self):
		return self.__root

	def insert(self,y):
		if self.__root:
			cur=self.__root
		else:
			self.__root=Node(y)
			return
		while True:
			if y<=cur.val and cur.left:
				cur=cur.left
			elif y>cur.val and cur.right:
				cur=cur.right
			else:
				break
		if y<=cur.val:
			cur.left=Node(y)
		elif y>cur.val:
			cur.right=Node(y)

	def find(self,y):
		if self.__root:
			cur=self.__root
		else:
			return -1
		while True:
			if y==cur.val:
				return True
			elif y<cur.val and cur.left:
				cur=cur.left
			elif y>cur.val and cur.right:
				cur=cur.right
			else:
				return False

	def delete(self,y):
		if self.__root:
			pre,cur=None,self.__root
		else:
		   	print "Empty Tree!"
			return
		while True:
	    		if y==cur.val:
				break
			elif y>cur.val and cur.right:
				pre,cur=cur,cur.right
			elif y<cur.val and cur.left:
				pre,cur=cur,cur.left
			else:
			   print "Node (with value %d) not found!"%y
			   return
	#If the node to be deleted has no children
		if not cur.left and not cur.right:
			if pre.left==cur:
				pre.left==None
			else:
				pre.right=None
	#If the node to be deleted has a child
		elif not cur.left or not cur.right:
			if not cur.left:
				if pre.left==cur:
					pre.left=cur.right
				else:
					pre.right=cur.right
			else:
				if pre.right==cur:
					pre.right=cur.left
				else:	
					pre.left=cur.left
	#If the node to be deleted has two children
		else:
	#Find the smallest node (a.k.a replacement-node) in the right subtree
			nextNode=cur.right 
			while nextNode.left:
				parentOfNextNode,nextNode=nextNode,nextNode.left

	#Detach the replacement-node from it's parent
			if parentOfNextNode.left==nextNode:
				parentOfNextNode.left=None
			else:
				parentOfNextNode.right=None

	#If the replacement-node has a child on right, attach the child to replacement node's parent
			if nextNode.right:
				parentOfNextNode.right=nextNode.right
	   			nextNode.right=None

	#Connect the replacement-node with the children of the node to be deleted
	   			nextNode.left=cur.left	
	   			nextNode.right=cur.right

	#Attach the replacement-node to the parent of the node to be deleted
	   		if pre.right==cur:
	   			pre.right=nextNode
	   		elif pre.left==cur:
	   			pre.left=nextNode
	   			print "Deleted node with value = %d"%y
		


	def getNodeRef(self,y):
		   if self.__root:
			   cur=self.__root
			   while True:
				   if y==cur.val:
					   return cur
				   elif y<cur.val and cur.left:
					   cur=cur.left
				   elif y>cur.val and cur.right:
					   cur=cur.right
				   else:
					   print "Node with value %d doesn't exist."%y
					   return
		   else:
			   print "Empty tree!"

   	def findParentRef(self,y):
		   if self.__root:
			   pre,cur=None,self.__root
			   while True:
				   if y==cur.val:
					   if  pre:
						   return pre
					   else:
						   print "This node has no parent (root node)."
						   break
			  	   elif y<cur.val and cur.left:
				   	pre,cur=cur,cur.left
				   elif y>cur.left and cur.right:
					   pre,cur=cur,cur.right
				   else:
					   print "Couldn't find a node with value %d!"%y
					   break
		   else:
			   print "Empty tree!"

	def findMin(self):
		if self.__root:
			cur=self.__root
			while cur.left:
				cur=cur.left
		   	return cur.val
	   	else:
			print "Empty tree!"

	def findMax(self):
		if self.__root:
			cur=self.__root
			while cur.right:
				cur.right
			return cur.val
		else:
			print "Empty tree!"

	def printTree(self,opt):
		if type(opt)==type(""):
			options={'pre':self.__preorderP,'in':self.__inorderP,'post':self.__postorderP}
			if opt in options:
				l=[]
				options[opt](self.__root,l)
				print l
				return l
			else:
				print "Invalid option!"

	def __inorderP(self,node,l=[]):
		if node:
			self.__inorderP(node.left)
			l.append(node.val)
			self.__inorderP(node.right)

	def __preorderP(self,node,l=[]):
		 if node:
			l.append(node.val)
			self.__preorderP(node.left)
			self.__preorderP(node.right)

	def __postorderP(self,node,l=[]):
		if node:
			self.__postorderP(node.left)
			self.__postorderP(node.right)
			l.append(node.val)

	def __dfs(self,node):
		if node:
			print node.val,
		else:
			return
		if node.left:	
			self.__dfs(node.left)
		if node.right:
			self.__dfs(node.right)

	def DFS(self):
		self.__dfs(self.__root)
		print ''

	def BFS(self):
		q=queue()
		node=self.__root
		if node:
			q.enqueue(node)
		else:
			return []
		while not q.isEmpty():
			node=q.dequeue()
			print node.val,
			if node.left:
				q.enqueue(node.left)
			if node.right:
				q.enqueue(node.right)
		print ''

	def __getH(self,node):
		if not node:
			return 0
		return 1+max(self.__getH(node.left),self.__getH(node.right))

	def getHeight(self):
		return self.__getH(self.__root)

	def __printGivenLevel(self,node,level):
		if not node:
			return
		if level==1:
			print node.val,
		elif level>1:
			self.__printGivenLevel(node.left,level-1)
			self.__printGivenLevel(node.right,level-1)

	def levelOrderTraversal_dfs(self):
		for i in range(1,self.getHeight()+1):
			self.__printGivenLevel(self.__root,i)
			print ''

	def levelOrderTraversal_bfs(self):
		curL,nexL=queue(),queue()
		if not self.__root:
			return
		curL.enqueue(self.__root)
		while not curL.isEmpty():
			node=curL.dequeue()
			if node:
				print node.val,
				if node.left:
					nexL.enqueue(node.left)
				if node.right:
					nexL.enqueue(node.right)
			if curL.isEmpty():
				print ''
				curL,nexL=nexL,curL


		
	
		
